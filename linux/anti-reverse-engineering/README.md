## How to protect your binary from reverse engineering

## Tools

### readelf
`readelf` is a command line utility that understands the Executable and
Linkable Format7 (ELF). ELF is the standard format for Linux executables,
shared libraries, and core dumps. readelf can parse provided binaries and
display information about their formatting.

### objdump
`objdump` displays information about one or more object files. The options
control what particular information to display.

### The -g flag
The -g option adds debug information to the binary. This is helpful when debugging, but leaks informations about the code.
Using `objdump --dwarf=info` we can read DWARF (debugging information) of our binary.
This way, one can obtain information such as the path of the source file, path of the compiler, and more importantly the name and the position of variables.
We should remove the `-g` flag when compiling for production.

### The -s flag
Despite having removed the `-g` flag, one can still obtain information from our binary.
In fact, by running `readelf --syms` we can read the symbol tab of our binary. This table contains information such variable and file names.
We can prevent the compiler from creating it with the `-s` flag.

### -fvisibility
Once removed the .symtab, we are left with the .dynsym table. In this table we can still get the starting address of our functions.
We can overcome this by adding the flag `-fvisibility=hidden` in the compilation.
Now, one can still see the function call and assembly code, but the name is autogenerated. This leaves the revengineer to figure out by himself what the funciton does.



### Make the code hard to understand: -O and -funroll-loops
#### Be careful with optimizations
At this point, a revengineer can decompile the code but function and variable names are unintelligible. Anyway, he could still be able to understand what the code does.
`-O` is a GCC flag to optimize the code. It has several options (ex `-O1`, `-O2`, `-O3`, `-Os`) that optimize code space or speed. Optimization for space can make the assembly code more similar to the source code. Be careful when using it because it makes easir the life of a revengineer.
On the other hand, optimizations for speed can create code that is much more difficult to read. 
As a general rule, always check the result of your optimizations.
#### -funroll-loops
Loop unrolling writes sequentially operations contained in loops whose iterations can be determined at compile time.
This results in higher performances of the code but also in a decompiled code that is much more difficult to read.

